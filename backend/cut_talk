#!/usr/bin/perl -w

use warnings;
use strict;

use SReview::Config;
use SReview::Config::Common;
use SReview::Job;
use WWW::Curl::Easy;

use DBI;

sub get_fragment_nginx($$$$) {
	my ($url, $start, $stop, $target) = @_;
	my $pref = ?

	if(defined($start)) {
		$url .= $pref . $start;
		$pref = "&";
	}
	if(defined($stop)) {
		$url .= $pref . $stop;
	}
	open OUTPUT, ">$target";
	$curl->setopt(CURLOPT_URL, $url);
	$curl->setopt(CURLOPT_WRITEDATA, \*OUTPUT);
	my $res = $curl->perform;
	if($res != 0) {
		die "Received HTTP error code $res: " . $curl->strerror($res) . " " $curl->errbuf;
	}
	close OUTPUT;
};

sub get_fragment_ffmpeg($$$$) {
	my ($file, $start, $stop, $target) = @_;

	my $command = "ffmpeg";

	if(defined($start)) {
		$command .= " -ss $start";
	}
	if(defined($stop)) {
		$command .= " -t $stop";
	}
	$command .= " -i $file -c copy $target";
};

my $config = SReview::Config->new('./sreview-backend.cf');

SReview::Config::Common::setup($config);
$config->define('cut_style', 'The style in which cuts are created: nginx_mp4 (adds URL query parts to a URL in the syntax as required by the nginx MP4 module), or file (uses ffmpeg commands directly on the file)', 'file');

my $dbh = DBI->connect($config->get('dbistring'));

my $cutstyle = $config->get('cut_style');

my $talkid = $ARGV[0];
die "Need a talk to work on!\n" unless defined($talkid);

my $talk_data = $dbh->prepare('SELECT talkid, rawid, raw_filename, extract(epoch from fragment_start) AS fragment_start, extract(epoch from raw_length) as raw_length, extract(epoch from raw_length_corrected) as raw_length_corrected FROM adjusted_raw_talks(?, make_interval(secs :=?::numeric), make_interval(secs := ?::numeric)) ORDER BY talk_start, raw_start');
my $corrections_data = $dbh->prepare('SELECT corrections.talk, properties.name AS property, corrections.property_value FROM corrections LEFT JOIN properties ON corrections.property = properties.id WHERE talk = ?');

my $get_fragment;

if($cutstyle eq 'nginx_mp4') {
	$get_fragment = \&get_fragment_nginx;
} else {
	$get_fragment = \&get_fragment_file;
}

my $tempdir = tempdir("cutXXXXXX", DIR => $config->{workdir}, CLEANUP => 1);

$corrections_data->execute($talkid);

while(my $row = $corrections_data->fetchrow_hashref()) {
	my $name = $row->{property};
	my $val = $row->{property_value};
	$corrections{$name} = $val;
}

foreach my $prop("offset_start", "length_adj", "offset_audio") {
	if(!exists($corrections{$prop})) {
		$corrections{$prop} = 0;
	}
}

if(!exists($corrections{audio_channel})) {
	$corrections{audio_channel} = 2;
}

$talk_data->execute($talkid, $corrections{"offset_start"}, $corrections{"length_adj"});

my $eventname = $dbh->prepare("SELECT events.id AS eventid, events.name AS event, rooms.name AS room, talks.starttime::date, talks.slug FROM talks JOIN events ON talks.event = events.id JOIN rooms ON rooms.id = talks.room WHERE talks.id = ?");

my $row = $eventname->fetchrow_hashref();
my $workdir = join('/', ($config->get('workdir'), $row->{eventid}, &{$config->workdir_mangle}($row->{room}, $row->{starttime})));
make_path($workdir);
my $outname = join('/', $workdir, $row->{slug});

my $prelen = 0;
my $mainlen = 0;
my $postlen = 0;

my @segments_pre;
my @segments_main;
my @segments_post;

my $exten = $config->get('raw_exten');

# extract the "useful" data from the raw recordings
while(my $row = $talk_data->fetchrow_hashref()) {
	my $target;
	my $segments;
	my $start = undef;
	my $stop = undef;
	my $source;
	next if ($row->{raw_length_corrected} == 0);
	if($row->{talkid} == -1) {
		$target = "pre";
		$segments = @segments_pre;
		if($prelen == 0 && $corrections{offset_audio} > 0) {
			if($row->{fragment_start} > 0) {
				$row->{fragment_start} -= ($corrections{offset_audio} > $row->{fragment_start}) ? $row->{fragment_start} : $corrections{offset_audio};
			}
		}
		$prelen += $row->{raw_length_corrected};
	} elsif($row->{talkid} == -2) {
		$target = "post";
		$segments = \@segments_post;
		$postlen += $row->{raw_length_corrected};
	} else {
		$target = "main";
		$segments = \@segments_main;
		$mainlen += $row->{raw_length_corrected};
	}
	if($row->{fragment_start} ne '0') {
		$start = $row->{fragment_start};
	}
	if($row->{raw_length} ne $row->{raw_length_corrected}) {
		$stop = ($row->{fragment_start} + $row->{raw_length_corrected});
	}
	$target = "$tempdir/$target" . $row->{rawid} . $exten;
	&$get_fragment($row->{raw_filenam}, $start, $stop, $target);
	push @$segments, $target;
}

if(!scalar(@segments_main)) {
	die "did not find any segments for main video";
}

# Deal with audio:
# - Concatenate all extracted segments, so we have a "continuous"
my @segments = (@segments_pre, @segments_main, @segments_post);
open CONCAT, ">$tempdir/concat.txt";
foreach my $segment(@segments) {
	print CONCAT "file '$segment'\n";
}
close CONCAT;
system("ffmpeg -f concat -safe 0 -i $tempdir/concat.txt -c copy -y $tempdir/full.$exten");

# - Choose the correct audio channel, and map that to an output wav file
my $channel = "-map_channel 0.1.0";
if(exists($corrections{audio_channel})) {
	if($corrections{audio_channel} eq 1) {
		$channel = "-map_channel 0.1.1";
	} elsif($corrections{audio_channel} == 2) {
		$channel = "-ac 1";
	}
}

system("ffmpeg -i $tempdir/full.$exten $channel -y $tempdir/full.wav");

# - Perform A/V sync if necessary
if($corrections{offset_audio} != 0) {
	if($corrections{offset_audio} > 0) {
		# delay audio by cuting off some of the video at the start
		system("ffmpeg -ss " . abs($corrections{offset_audio}) . " -i $tempdir/full.$exten -c copy -y $tempdir/full-new.$exten");
		$prelen -= $corrections{offset_audio};
		if($prelen < 0) {
			$mainlen -= abs($prelen);
			$prelen = 0;
		}
		unlink("$tempdir/full.$exten");
		rename("$tempdir/full-new.$exten", "$tempdir/full.$exten");
	} else {
		# delay video by cutting off some of the audio at the start
		system("ffmpeg -ss " . abs($corrections{offset_audio}) . " -i $tempdir/full.wav -c copy -y $tempdir/full-new.wav");
		$postlen -= $corrections{offset_audio};
		if($postlen < 0) {
			$mainlen -= abs($postlen);
			$postlen = 0;
		}
		unlink("$tempdir/full.wav");
		rename("$tempdir/full-new.wav", "$tempdir/full.wav");
	}
}

my $acodec_opts = $config->get('ffmpeg_a_codec');
# Now split and merge the full video and audio files into three video files with the audio reattached
system("ffmpeg -i $tempdir/full.$exten -i $tempdir/full.wav -t $prelen -c:v copy $acodec_opts -map 0:v -map 1:a -y $outname-pre.$exten");
system("ffmpeg -i $tempdir/full.$exten -i $tempdir/full.wav -ss " . ($prelen + $mainlen) . " -c:v copy $acodec_opts -map 0:v -map 1:a -shortest -y $outname-post.$exten");
system("ffmpeg -i $tempdir/full.wav -ss $prelen -t $mainlen -c copy $tempdir/audio.wav");
system("ffmpeg -i $tempdir/full.$exten -ss $prelen -t $mainlen -c copy $tempdir/preaudio.$exten");
# Run bs1770gain (which creates a FLAC file)
system("bs1770gain -a -o $tempdir $tempdir/audio.wav");
# Replace original audio stream with normalized one
system("ffmpeg -i $tempdir/preaudio.mp4 -i $tempdir/audio.flac $acodec_opts -c:v copy -map 0:v -map 1:a -shortest -y $outname.$exten");

# Detect the size of the cut videos to be sure they're correct
if(scalar(@segments_pre) > 0) {
	open INFO, "ffprobe $outname-pre.$exten 2>&1|";
	while(<INFO>) {
		next unless /Duration: ([0-9]+:[0-9]+:[0-9]+.[0-9]+)/;
		$prelen = $1;
		last;
	}
	close INFO;
}
if(scalar(@segments_pre) > 0) {
	open INFO, "ffprobe $outname-post.$exten 2>&1|";
	while(<INFO>) {
		next unless /Duration: ([0-9]+:[0-9]+:[0-9]+.[0-9]+)/;
		$postlen = $1;
		last;
	}
	close INFO;
}
open INFO, "ffprobe $outname.$exten 2>&1|";
while(<INFO>) {
	next unless /Duration: ([0-9]+:[0-9]+:[0-9]+.[0-9]+)/;
	$mainlen = $1;
	last;
}
close INFO;

# Now update the database
my $update = $dbh->prepare("UPDATE talks SET state = 'needs_notify', prelen = ?::interval, postlen = ?::interval, mainlen = ?::interval WHERE id = ? AND state = 'cut_pending'");
$update->execute("$prelen seconds", "$postlen seconds", $talkid);

$dbh->commit;
